import { on } from "./events/on.js";
import { postEvent as defaultPostEvent } from "./methods/postEvent.js";
import { isRecord } from "../misc/isRecord.js";
import { withTimeout } from "../timeout/withTimeout.js";
export function request(method, eventOrParams, eventOrOptions, options) {
  let executionOptions;
  let methodParams;
  let events;
  let requestId;
  if (typeof eventOrParams === 'string' || Array.isArray(eventOrParams)) {
    // Override: [method, event, options?]
    events = Array.isArray(eventOrParams) ? eventOrParams : [
      eventOrParams
    ];
    executionOptions = eventOrOptions;
  } else {
    // Override: [method, params, event, options?]
    methodParams = eventOrParams;
    events = Array.isArray(eventOrOptions) ? eventOrOptions : [
      eventOrOptions
    ];
    executionOptions = options;
  }
  // In case, method parameters were passed, and they contained request identifier, we should store
  // it and wait for the event with this identifier to occur.
  if (isRecord(methodParams) && typeof methodParams.req_id === 'string') {
    requestId = methodParams.req_id;
  }
  const { postEvent = defaultPostEvent, timeout } = executionOptions || {};
  const capture = executionOptions && 'capture' in executionOptions ? executionOptions.capture : null;
  const execute = ()=>{
    return new Promise((res, rej)=>{
      // Iterate over each event and create event listener.
      const stoppers = events.map((ev)=>on(ev, (data)=>{
          // If request identifier was specified, we are waiting for event with the same value
          // to occur.
          if (requestId && (!isRecord(data) || data.req_id !== requestId)) {
            return;
          }
          if (typeof capture === 'function' && !capture(data)) {
            return;
          }
          // eslint-disable-next-line @typescript-eslint/no-use-before-define
          stopListening();
          res(data);
        }));
      // Function which removes all event listeners.
      const stopListening = ()=>stoppers.forEach((stop)=>stop());
      try {
        // We are wrapping this call in try catch, because it can throw errors in case,
        // compatibility check was enabled. We want an error to be captured by promise, not by
        // another one external try catch.
        postEvent(method, methodParams);
      } catch (e) {
        stopListening();
        rej(e);
      }
    });
  };
  return typeof timeout === 'number' ? withTimeout(execute, timeout) : execute();
}
//# sourceMappingURL=request.js.map