import { Logger } from "../../logger/Logger.js";
import { ensurePrefix } from "../ensurePrefix.js";
/**
 * Represents basic navigator implementation which uses only memory to store and control
 * navigation state.
 */ export class Navigator {
  entriesCursor;
  logger;
  entries;
  constructor(entries, entriesCursor, { debug = false, loggerPrefix = 'Navigator' }){
    this.entriesCursor = entriesCursor;
    if (entries.length === 0) {
      throw new Error('Entries list should not be empty.');
    }
    if (entriesCursor >= entries.length) {
      throw new Error('Cursor should be less than entries count.');
    }
    this.entries = entries.map(({ pathname = '', search, hash })=>{
      if (!pathname.startsWith('/') && pathname.length > 0) {
        throw new Error('Pathname should start with "/"');
      }
      return {
        pathname: ensurePrefix(pathname, '/'),
        search: search ? ensurePrefix(search, '?') : '',
        hash: hash ? ensurePrefix(hash, '#') : ''
      };
    });
    this.logger = new Logger(`[${loggerPrefix}]`, debug);
  }
  /**
   * Converts entry to the navigation entry.
   * @param entry - entry data
   */ formatEntry(entry) {
    let path;
    if (typeof entry === 'string') {
      path = entry;
    } else {
      const { pathname = '', search, hash } = entry;
      path = pathname + (search ? ensurePrefix(search, '?') : '') + (hash ? ensurePrefix(hash, '#') : '');
    }
    const { pathname, search, hash } = new URL(path, `https://localhost${this.path}`);
    return {
      pathname,
      search,
      hash
    };
  }
  /**
   * Current entry.
   */ get entry() {
    return this.entries[this.entriesCursor];
  }
  /**
   * Goes back in history.
   */ back() {
    return this.go(-1);
  }
  /**
   * Current entries cursor.
   */ get cursor() {
    return this.entriesCursor;
  }
  /**
   * True if navigator can go back.
   */ get canGoBack() {
    return this.entriesCursor > 0;
  }
  /**
   * True if navigator can go forward.
   */ get canGoForward() {
    return this.entriesCursor !== this.entries.length - 1;
  }
  /**
   * Goes forward in history.
   */ forward() {
    return this.go(1);
  }
  /**
   * Moves entries cursor by specified delta.
   * @param delta - cursor delta.
   */ go(delta) {
    this.logger.log(`called go(${delta})`);
    // Cursor should be in bounds: [0, this.entries).
    const cursor = Math.min(this.entries.length - 1, Math.max(this.entriesCursor + delta, 0));
    if (this.entriesCursor === cursor) {
      return this.performGo({
        updated: false,
        delta
      });
    }
    const before = this.entry;
    this.entriesCursor = cursor;
    const after = this.entry;
    this.logger.log('State changed', {
      before,
      after
    });
    return this.performGo({
      updated: true,
      delta,
      before,
      after
    });
  }
  /**
   * Returns copy of navigator entries.
   */ getEntries() {
    return this.entries.map((entry)=>({
        ...entry
      }));
  }
  /**
   * Current hash.
   * @example
   * "", "#", "#hash"
   */ get hash() {
    return this.entry.hash;
  }
  /**
   * Pushes new entry. Method replaces all entries after the current one with the inserted.
   * @param entry - entry data.
   *
   * @example Pushing absolute pathname.
   * push("/absolute-path"); // "/absolute-path"
   *
   * @example Pushing relative pathname.
   * // Pushing relative path replaces N last path parts, where N is pushed pathname parts count.
   * // Pushing empty path is recognized as relative, but not replacing the last pathname part.
   * push("relative"); // "/home/root" -> "/home/relative"
   *
   * @example Pushing query parameters.
   * push("/absolute?my-param=1"); // "/home" -> "/absolute?my-param=1"
   * push("relative?my-param=1"); // "/home/root" -> "/home/relative?my-param=1"
   * push("?my-param=1"); // "/home" -> "/home?my-param=1"
   *
   * @example Pushing hash.
   * push("#my-hash"); // "/home" -> "/home#my-hash"
   * push("johny#my-hash"); // "/home/root" -> "/home/johny#my-hash"
   */ push(entry) {
    // In case, current cursor refers not to the last one element in the history, we should
    // remove everything after the cursor.
    if (this.entriesCursor !== this.entries.length - 1) {
      this.entries.splice(this.entriesCursor + 1);
    }
    const formatted = this.formatEntry(entry);
    const before = this.entry;
    this.entriesCursor += 1;
    this.entries[this.entriesCursor] = formatted;
    const after = this.entry;
    this.logger.log('State changed', {
      before,
      after
    });
    return this.performPush({
      before,
      after
    });
  }
  /**
   * Current full path including pathname, query parameters and hash.
   */ get path() {
    return `${this.pathname}${this.search}${this.hash}`;
  }
  /**
   * Current pathname.
   * @example
   * "/", "/abc"
   */ get pathname() {
    return this.entry.pathname;
  }
  /**
   * Replaces current entry. Has the same logic as `push` method.
   * @param entry - entry data.
   * @see push
   * @returns True if changes were done.
   */ replace(entry) {
    const formattedEntry = this.formatEntry(entry);
    if (this.search === formattedEntry.search && this.pathname === formattedEntry.pathname && this.hash === formattedEntry.hash) {
      return this.performReplace({
        updated: false,
        entry: formattedEntry
      });
    }
    const before = this.entry;
    this.entries[this.entriesCursor] = formattedEntry;
    const after = this.entry;
    this.logger.log('State changed', {
      before,
      after
    });
    return this.performReplace({
      updated: true,
      before,
      after
    });
  }
  /**
   * Current query parameters.
   * @example
   * "", "?", "?a=1"
   */ get search() {
    return this.entry.search;
  }
}
//# sourceMappingURL=Navigator.js.map